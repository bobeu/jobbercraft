{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Receiver.sol\";\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/main/curators/Curators.sol": {
      "content": "/** SPDX-License-Identifier: MIT\r\n*/\r\npragma solidity 0.8.19;\r\n\r\nimport \"../../../node_modules/@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/** @title Curator\r\n\r\n    ERROR CODE\r\n    ---------\r\n    \"21\" : Out of bound error\r\n    \"22\" : Registered\r\n    \"23\" : Not a curator\r\n\r\n */\r\nabstract contract Curators is Ownable {\r\n  enum Status { NONE, REGISTERED, WHITELISTED }\r\n  struct Curator {\r\n    Status status;\r\n    uint id;\r\n    address addr;\r\n  }\r\n\r\n  // Curators\r\n  Curator[] public curators;\r\n\r\n  // Curators curatorsId\r\n  mapping(address => uint) public curatorsId;\r\n\r\n  // Mapping of curators to jobId\r\n  mapping(address => mapping(uint => bool)) private isCurator;\r\n\r\n  // Validate permissions\r\n  modifier checkEligibility(uint8 selector, string memory errorMessage) {\r\n    if(selector > 2) revert('21');\r\n    require(_curatorStatus(_msgSender()) == Status(selector), errorMessage);\r\n    _;\r\n  }\r\n\r\n  /**@dev We initialize the curators array with an empty element. This helps \r\n      us properly track valid curators easily. Approved Curators cannot have \r\n      zero id.\r\n   */\r\n  constructor() {\r\n    curators.push();\r\n  }\r\n\r\n  // Return the current status of a curator\r\n  function _curatorStatus(address target) internal view returns(Status status) {\r\n    uint id = curatorsId[target];\r\n    status = curators[id].status;\r\n  }\r\n\r\n  // Registers a new curator. Such address must not have been registered\r\n  function becomeACurator() public checkEligibility(0, \"22\") {\r\n    address caller = _msgSender();\r\n    uint id = curators.length;\r\n    curatorsId[caller] = id; \r\n    curators.push(Curator(Status.REGISTERED, id, caller));\r\n  }\r\n\r\n  // Curators are free to remove themselves\r\n  function deleteMe() public {\r\n    address caller = _msgSender();\r\n    uint id = curatorsId[caller];\r\n    require(id > 0, '23');\r\n    delete curators[id];\r\n    curatorsId[caller] = 0;\r\n  }\r\n\r\n  /**@dev Only Owner can whitelist curators.\r\n    Such address must have been registered before the invocation can be \r\n    successful.\r\n  */ \r\n  function whitelistCurators(address[] memory targets) public onlyOwner {\r\n    for(uint i = 0; i < targets.length; i++) {\r\n      address target = targets[i];\r\n      uint id = curatorsId[target];\r\n      if(_curatorStatus(target) == Status.REGISTERED) {\r\n        curators[id].status = Status.WHITELISTED;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return curators status to none\r\n  function blacklistCurators(address[] memory targets) public onlyOwner {\r\n    for(uint i = 0; i < targets.length; i++) {\r\n      curators[curatorsId[targets[i]]].status = Status.NONE;\r\n    }\r\n  }\r\n\r\n  // Return curator's address.\r\n  function _getCuratorAddr(uint curatorId) internal view returns(address _curator) {\r\n    require(curatorId < curators.length, \"21\");\r\n    _curator = curators[curatorId].addr;\r\n  }\r\n\r\n}"
    },
    "contracts/main/HiWork.sol": {
      "content": "// SPDX-License-Identifier: MIT \r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"./ReadOnly.sol\";\r\nimport \"../utils/Lib.sol\";\r\nimport \"../utils/SafeCall.sol\";\r\nimport \"./interfaces/ITrustee.sol\";\r\nimport \"./Trustee.sol\";\r\nimport \"./curators/Curators.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/interfaces/IERC721.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n/**                                                     \r\n      @@@\\   @@@\\              @@@\\       @@@\\    @@@@@ \\   @@@@@@@@ \\   @@@\\  @@@\\\r\n      @@@ |  @@@ |  @@@@@@@\\   @@@ |      @@@ |  @@@@@@@ \\  @@@   @@@ )  @@@ |@@@ /\r\n      @@@ |  @@@ |  @@@@@@@ |  @@@ |      @@@ | @@@   @@@ | @@@  @@@ /   @@@ @@@ /\r\n      @@@@@@@@@@ |    @@@ _\\|  @@@ |      @@@ | @@@   @@@ | @@@@@@@ /    @@@@@@ /\r\n      @@@@@@@@@@ |    @@@ |    @@@ | @@@\\ @@@ | @@@   @@@ | @@@@@@  \\    @@@@@@ \\\r\n      @@@  _ @@@ |    @@@ |    @@@ |_@@@ |@@@ | @@@   @@@ | @@@  _@@ \\   @@@ @@@ \\\r\n      @@@ |  @@@ |  @@@@@@@\\   @@@@@  _ @@@@@ |  @@@@@@@  | @@@ | @@@ \\  @@@  @@@ \\\r\n      @@@ |  @@@ |  @@@@@@@ |  @@@@@ |  @@@@@ |   @@@@@  /  @@@ | @@@@ | @@@ | @@@ |\r\n      \\__\\|  \\__\\|  \\______\\|  \\____\\|  \\____\\|    \\___\\/   \\__\\| \\___\\| \\__\\| \\__\\|\r\n*/\r\n\r\n\r\n/**\r\n    ERROR CODE\r\n    ----------\r\n    \"1\" : \"Not a member\".\r\n    \"2\" : \"No interested participants yet\".\r\n    \"4\" : \"Probation hit limit.\r\n    \"6\" : \"Invalid caller\".\r\n    \"7\" : \"Invalid entry\".\r\n    \"8\" : \"Approval to zero address\".\r\n    \"9\" : \"Already signed\".\r\n    \"11\" : \"Insufficient value provided\".\r\n    \"13\" : \"Time elapsed: Cannot initialize again\".\r\n    \"14\" : \"Offer price less than minimumOffer\". \r\n    \"15\" : Only owner | curator.\r\n    \"16\" : Low bal\r\n    \"17\" : OnlyOwner\r\n\r\n*/\r\n\r\ncontract HiWork is ReadOnly, Pausable, Curators {\r\n  using Lib for *;\r\n\r\n  error TestError(address pay, uint offer, address caller);\r\n\r\n  // Contract initializer. Useful in testing and minor upgrade\r\n  uint8 private initializer;\r\n\r\n  //Mapping of hirer to trustee\r\n  mapping (address => address) public trustees;\r\n\r\n  // Caller must be a valid member of HiWork\r\n  modifier isValidMember() {\r\n    require(_queryJobberStatus(_msgSender()) > 0, \"1\");\r\n    _;\r\n  }\r\n\r\n  /**@dev Initialized storage vars \r\n   * @param _initializer : Used to set initial parameters. \r\n   *  The parameters can only be altered the number of times the _initializer was set.\r\n  */\r\n  constructor (\r\n    uint8 _initializer, \r\n    address _feeTo\r\n    // uint8 _cancellationRate,\r\n    // uint256 _minimMumOffer, \r\n    // address _paymentCurrency,\r\n    // address _jobbersContract\r\n  ) Storage(_feeTo) { \r\n    initializer = _initializer; \r\n    //  _initialize (\r\n    //   _cancellationRate, \r\n    //   _minimMumOffer, \r\n    //   _jobbersContract, \r\n    //   _paymentCurrency\r\n    // );\r\n  }\r\n\r\n  function initialize (\r\n    uint8 _cancellationRate,\r\n    uint256 _minimMumOffer, \r\n    address _paymentCurrency,\r\n    address _jobbersContract\r\n  ) public onlyOwner {\r\n      require(initializer > 0, \"13\");\r\n      initializer --;\r\n    _initialize (\r\n      _cancellationRate, \r\n      _minimMumOffer, \r\n      _paymentCurrency,\r\n      _jobbersContract \r\n    );\r\n  }\r\n\r\n  //Fallback/Receive func\r\n  receive () external payable {\r\n    Address.sendValue(payable(feeTo), msg.value);\r\n  }\r\n\r\n  /**@dev Posts new Job\r\n          @param jobRef - Can be Job URL or any reference to the current job.\r\n          @param proposedEndDateInDays - Expected duration to complete the job.\r\n          @param curatorId : On the frontend, curators are mapped to their respective ids,\r\n                  Hirers may add curator service or not.\r\n          @param offerPrice : The amount in stable coin the hirer is willing to pay for this job.\r\n          Note - Hirer must have given approval to withdraw the offerPrice in cUSD, which\r\n                  must also be greater than minimum offer.\r\n                  Note : Payment currency is in cUSD. \r\n  */\r\n  function postJob(\r\n    uint8 jobType,\r\n    string memory title,\r\n    string[] memory tags,\r\n    string memory jobRef, \r\n    uint16 proposedEndDateInDays, \r\n    uint offerPrice, \r\n    uint curatorId\r\n  ) external payable whenNotPaused returns(uint jobId) {\r\n    address _trustee = trustees[_msgSender()];\r\n    address to = address(this);\r\n    if(_trustee == address(0)) {\r\n      _trustee = address(new Trustee(_msgSender(), paymentCurrency));\r\n      trustees[_msgSender()] = _trustee;\r\n    }\r\n    paymentCurrency\r\n      .getAllowance(_msgSender(), to)\r\n        .uint256GE(minimMumOffer, '14')\r\n          .uint256GE(offerPrice, '14')\r\n            .uint256G(1 ether, '14')\r\n              .spendAllowance(paymentCurrency, _msgSender(), _trustee);\r\n\r\n    unchecked {\r\n      offerPrice = offerPrice - 1 ether;\r\n    }\r\n    jobId = _postJob(jobType, title, tags, jobRef,  uint64(proposedEndDateInDays * 1 days),  offerPrice - 1 ether,  _msgSender(),  _getCuratorAddr(curatorId));\r\n    emit JobCreated(jobId, offerPrice, _trustee, jobRef);\r\n    \r\n    return jobId;\r\n  }\r\n\r\n  /**\r\n    @dev Jobbers show interest to work on a particular job\r\n        @param jobId - The Job id Jobber is applying for. An id not greater than the job array \r\n          length is expected.\r\n        @param proposedCompletionDateInDays - Jobbers can propose completion date.\r\n          This however should not be confused for that of the hirer. Hirer will eventually\r\n          accept or reject the proposal date. \r\n        Note: The parameter \"proposedCompletionDateInDays\" should be in days e.g 7\r\n        @param myBestPrice - Best price jobber will accept the job. This enables better negotiation\r\n          thereby protecting the interests and rights of both parties.\r\n        \r\n        Note: Intending Jobber applying for this job must either be on probation or approved member.  \r\n   */\r\n  function requestToWork(\r\n    uint256 jobId, \r\n    uint16 proposedCompletionDateInDays, \r\n    uint256 myBestPrice\r\n  ) external whenNotPaused isValidMember isJobIdValid(jobId) enforceJobStatus(jobId, JobStatus.OPEN) returns(bool) {\r\n    JobMetadata memory j = _getJobData(jobId);\r\n    address caller = _msgSender();\r\n    uint bestRate = myBestPrice == 0 ? j.job.offerPrice : myBestPrice;\r\n    uint64 completionDate = proposedCompletionDateInDays == 0 ? j.job.proposeEnd : proposedCompletionDateInDays * 1 days;\r\n    \r\n    _enforceJobOfferLimit(j.job.offerPrice, caller);\r\n    _enforceCompliance(caller);\r\n    require(proposedCompletionDateInDays > 0 && proposedCompletionDateInDays < 365 days, \"7\");\r\n    _createAndUpdateNewRequest(\r\n      caller, \r\n      jobId,\r\n      completionDate,\r\n      bestRate\r\n    );\r\n\r\n    _postComplianceFor(caller, block.timestamp);\r\n\r\n    emit WorkRequested(jobId, caller, j.job.offerPrice, myBestPrice, completionDate);\r\n    return true;\r\n  }\r\n\r\n  /**@dev Hirer accepts request (s) to work on job.\r\n        @param jobId - Job index\r\n        @param selectedPositions - List of jobbers hirer accepts \r\n                            to collaborate on the job.\r\n                            It should contain jobbers' \r\n                            position Id.\r\n        Note - Caller be the creator of job at jobId\r\n              - Job must be open.\r\n              - There must be requests greater than 0.\r\n              It is assumed Hirer has scrutinized properly, the interests shown in job at \r\n                jobId, hence, proposed completion time of each collaborator is \r\n                evaluated, and that best satisfy the hirer's interest.\r\n  */\r\n  function approveRequests(\r\n    uint jobId, \r\n    uint8[] memory selectedPositions\r\n  ) \r\n    external \r\n    whenNotPaused \r\n    isJobIdValid(jobId) \r\n    enforceJobStatus(jobId, JobStatus.OPEN)\r\n    returns(bool)\r\n  {\r\n    JobMetadata memory j = _getJobData(jobId);\r\n    _onlyHirerOrCurator(j.job.hirer, _msgSender(), j.curator, true);\r\n    j.requests.length.uint256GE(1, \"2\");\r\n    for(uint8 i = 0; i < selectedPositions.length; i++) {\r\n      uint8 sel = uint8(selectedPositions[i]);\r\n      j.requests[sel].identifier.addressNE(address(0), \"8\");\r\n      uint64 jobbersProposedJobEnd = j.requests[sel].proposedJobEnd;\r\n      _updateRequest(jobId, sel);\r\n      if(jobbersProposedJobEnd > j.job.proposeEnd) {\r\n        _updateProposeEndDate(jobId, jobbersProposedJobEnd);\r\n      }\r\n    }\r\n    _setStatus(jobId, JobStatus.TAKEN);\r\n\r\n    emit RequestApproved(jobId, selectedPositions);\r\n    return true;\r\n  }\r\n\r\n   /**@dev Utility to submit completed jobs.\r\n        Note: We enforce strict rules that ensure caller is a \r\n                valid collaborator since position of any valid\r\n                collaborator will always be greater than zero. \r\n          - If there is only one collaborator, we simply set \r\n              completion and exit the program.\r\n          - If collaborator is more than one, we check that caller's \r\n              signature is not appended before now, otherwise the program reverts.\r\n\r\n        Note If collaborator is more than one, then minimum of 2 signatures\r\n              are required to  set job state to `completed`.\r\n      @param jobId - Job index/position.\r\n   */\r\n  function submitAndSignCompletion(uint jobId) \r\n    public \r\n    isValidMember \r\n    isJobIdValid(jobId) \r\n    whenNotPaused\r\n    enforceJobStatus(jobId, JobStatus.TAKEN) \r\n    returns(bool _return)\r\n  {\r\n    JobMetadata memory j = _getJobData(jobId);\r\n    address caller = _msgSender();\r\n    uint8 pos = _getPosition(caller, jobId);\r\n    j.requests[pos].signed.boolEq(false, \"9\");\r\n    if(j.requests.length == 1) return _setStatus(jobId, JobStatus.COMPLETED);\r\n    uint8 sig;\r\n    //If there was at least one signature\r\n    if((j.job.signature + 1) == 2) {\r\n      sig = 2;\r\n      _return = _setStatus(jobId, JobStatus.COMPLETED);\r\n    }\r\n\r\n    //If there was no previous signature\r\n    if((j.job.signature + 1) < 2) {\r\n      sig = 1;\r\n      _return = true;\r\n    }\r\n    _updateSignature(jobId, sig);\r\n    _updateSignedFlag(jobId, pos);\r\n    emit Submission(jobId, caller);\r\n\r\n    return _return;\r\n  }\r\n\r\n  /**Hirer confirms and approve that job at jobId was completed and final.\r\n        Note - Payment (less fee) is splitted among the jobbers.\r\n              o Jobbers are able to withdraw payment from the trustee.\r\n              o Rewards are minted to jobbers.\r\n               Function is able to handle if there was collaboration or not.\r\n        @param jobId - Job index.\r\n  \r\n  */\r\n  function approveCompletion(uint jobId) \r\n    external \r\n    whenNotPaused\r\n    enforceJobStatus(jobId, JobStatus.COMPLETED) \r\n    isJobIdValid(jobId) returns(bool) \r\n  {\r\n    JobMetadata memory j = _getJobData(jobId);\r\n    _onlyHirerOrCurator(j.job.hirer, _msgSender(), j.curator, true);\r\n    _setStatus(jobId, JobStatus.CLOSED);\r\n    (uint256 netPay, uint256 fee) = j.job.offerPrice.getNetPay();\r\n    address _trustee = trustees[j.job.hirer];\r\n    // uint len = j.requests.length;\r\n    // require(_trustee != address(0), 'd');\r\n    unchecked {\r\n      SafeCall.safeSplit(ITrustee(_trustee), j.requests, netPay, fee + 1 ether, 0, feeTo);\r\n    }\r\n\r\n    emit JobCompleted(jobId);\r\n    return true;\r\n  }\r\n\r\n  /**@dev Internal: Enforces that Probationary members cannot accept jobs with \r\n      offer above certain limit e.g $500\r\n      @param offerPrice - Actual price Hirer is willing to pay for\r\n                            the job offer.\r\n      Note :  We enquire from HPM NFT contract if caller owns a \r\n                balance. We can be sure that each jobber cannot hold\r\n                more than 1 NFT collection at any time.\r\n            o NFT membership is not transferable.\r\n   */\r\n  function _enforceJobOfferLimit(uint256 offerPrice, address jobber) internal view {\r\n    uint256 c1 = IJobbers(jobberContract).getAvatarInfo(jobber); \r\n    if(c1 == 1) {\r\n      if(probationOfferLimit > 0) {\r\n        offerPrice.uint256LE(probationOfferLimit, \"4\");\r\n      }\r\n    }\r\n  }\r\n\r\n  ///@dev Checks if caller is the hirer with jobId\r\n  function _onlyHirerOrCurator(address hirer, address caller, address curator, bool doubleCheck) internal virtual {\r\n    bool pass;\r\n    if(caller == hirer) pass = true;\r\n    if(!pass && doubleCheck) {\r\n      if(curator != address(0)) {\r\n        if(caller == curator) pass = true;\r\n      }\r\n    }\r\n    require(pass, \"15\");\r\n  }\r\n\r\n  /**@dev Cancels job offer @param jobId - {Job index}\r\n      Note \r\n        - Caller must be the hirer of Job with valid JobId.\r\n        - Caller must not be a contract address.\r\n        For more info, see { Storage.sol - _removeJob }\r\n  \r\n   */\r\n  function cancelJob(uint jobId) external whenNotPaused isJobIdValid(jobId) returns(bool) {\r\n    (uint refund, uint platformFee, uint splittable, Jobber[] memory requests) = _removeJob(jobId);\r\n    address _trustee = trustees[_msgSender()];\r\n    SafeCall.safeSplit(ITrustee(_trustee), requests, splittable, platformFee, refund, feeTo);\r\n\r\n    emit JobCanceled(jobId, refund, splittable);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    @dev Withdraws from this contract if any.\r\n        Note - Owner's privilege.\r\n        @param to - Address to send funds to.\r\n        @param amount - Amount to withdraw.\r\n   */\r\n  function withdraw(address to, uint amount) public onlyOwner{\r\n    if(address(this).balance < amount) revert();\r\n    (bool s,) = to.call{value: amount}(\"\");\r\n    if(!s) revert();\r\n  }\r\n\r\n  /** \r\n    @dev Halts contract execution \r\n      Note: Owner's privilege\r\n  */\r\n  function pause() public onlyOwner { _pause(); }\r\n\r\n  /** \r\n    @dev Continues contract execution \r\n      Note: Owner's privilege\r\n  */\r\n  function unpause() public onlyOwner { _unpause(); }\r\n\r\n    /**\r\n    @dev Reset cancellation fee.\r\n        Note - Owner's privilege.\r\n        @param newRate - Cancellation rate.\r\n         Rate should not be greater than 100%.\r\n   */\r\n  function setCancellationRate(uint8 newRate) public onlyOwner {\r\n    newRate.uint8L(100, \"7\");\r\n    _setCancellationRate(newRate);\r\n  }\r\n\r\n  // /**\r\n  //   @dev Upgrade or downgrade'target'\r\n  //     o 'target' must be the probation member.\r\n  //     o Upgrader must be approved client.\r\n  //  */\r\n  // function upgradeOrDowngradeUser(address target, uint8 upgrade_) public whenNotPaused onlyApprovedOrOwner {\r\n  //   if(upgrade_ == 1) {\r\n  //     _upgrade(target);\r\n  //     emit MembershipUpgraded(target);\r\n  //   } else {\r\n  //     _downgrade(target);\r\n  //     emit MembershipDowngraded(target);\r\n  //   }\r\n  // }\r\n\r\n  // /**\r\n  //   @dev User sign up to be probation member.\r\n  //     o Caller's current membership status must be null.\r\n  //     o Must send along with call the sufficient value for signup fee.\r\n  // */\r\n  // function becomeAJobber() external payable whenNotPaused returns(bool) {\r\n  //   uint probFee = mShip.probFee;\r\n  //   // if(msg.value < probFee) revert();\r\n  //   bool(msg.value >= probFee).boolEq(true, \"11\");\r\n  //   _forwardFee(msg.value);\r\n  //   _signUp(_msgSender());\r\n  //   return true;\r\n  // }\r\n\r\n  // //See Storage.sol\r\n  // function updateMembershipInfo(\r\n  //   uint probFee,\r\n  //   // uint approFee,\r\n  //   address approver,\r\n  //   address probationer,\r\n  //   address upgrader\r\n  // ) public onlyOwner {\r\n  //   _setMembershipVars(\r\n  //     probFee,\r\n  //     // approFee,\r\n  //     approver,\r\n  //     probationer,\r\n  //     upgrader\r\n  //   );\r\n  // }\r\n\r\n  // function suspendMembership(uint8 selector) public onlyOwner {\r\n  //   address[2] memory nfts = [mShip.probationer, mShip.approver];\r\n  //   IERC721Extended(nfts[selector]).pause();\r\n  // }\r\n\r\n  // function activateMembership(uint8 selector) public onlyOwner {\r\n  //   address[2] memory nfts = [mShip.probationer, mShip.approver];\r\n  //   IERC721Extended(nfts[selector]).unpause();\r\n  // }\r\n\r\n  function _beforeInvocation() internal view override {\r\n    require(_msgSender() == owner(), \"17\");\r\n  }\r\n\r\n}\r\n\r\n\r\n   // for (uint i = 0; i < len; i++) {\r\n    //   address to = j.requests[i].identifier;\r\n    //   unchecked {\r\n    //     SafeCall.safeIncreaseAllowance(\r\n    //       token, \r\n    //       to, \r\n    //       _getRewardBase(\r\n    //         _status(to)\r\n    //       ) * (10 ** IERC20Metadata(token).decimals()));\r\n    //   }\r\n    // }\r\n\r\n\r\n    "
    },
    "contracts/main/interfaces/ICommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface ICommon {\r\n    /**@dev Categories of jobber.  */\r\n  enum Tier { NONE, PROBATION, APPROVED }\r\n\r\n  struct Membership {\r\n    Tier status;\r\n    uint avatarId;\r\n    JobberData other;\r\n  }\r\n\r\n  // struct Membership {\r\n  //   bool approved;\r\n  //   uint tokenId;\r\n  // }\r\n\r\n  //Jobber's data type\r\n  // struct Jobber {\r\n  //   uint64 proposedJobEnd;\r\n  //   uint256 myBestPrice;\r\n  //   address identifier;\r\n  //   bool signed;\r\n  //   bool acceptance;\r\n  // }\r\n\r\n  // membership\r\n  struct MembershipBase {\r\n    uint probFee;\r\n    address approver;\r\n    address probationer;\r\n    address upgrader;\r\n  }\r\n\r\n  struct JobberData {\r\n    bytes name;\r\n    bytes aka;\r\n    bytes field;\r\n    bytes profileURI;\r\n    bytes avatar;\r\n    uint8 ratings;\r\n  }\r\n  \r\n}"
    },
    "contracts/main/interfaces/IJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"./ICommon.sol\";\r\n\r\ninterface IJob {\r\n  error InvalidSelector(uint8);\r\n\r\n  event CompletedJob(uint jobId, uint newSpotId, address indexed _trustee, address indexed hirer);\r\n  event JobCanceled(uint jobId, uint amountRefundToHirer, uint amountPaidToJobbers);\r\n  event JobCreated(uint jobId, uint offer, address trustee, string detail);\r\n  event WorkRequested(\r\n    uint jobId, \r\n    address indexed jobber, \r\n    uint actualOffer, \r\n    uint negotiatedPrice, \r\n    uint proposedCompletionDateInDays\r\n  );\r\n  event RequestApproved(uint jobId, uint8[] jobbers);\r\n  event Submission(uint jobId, address indexed jobber);\r\n  event JobCompleted(uint jobId);\r\n\r\n  /**@dev Steps of jobs. Each job inherits the {JobStatus.CLOSED} status by default which is \r\n    synchronous, and can only be in one step at any given time.  \r\n   */\r\n  enum JobStatus { NULL, OPEN, TAKEN, COMPLETED, CLOSED }\r\n\r\n  // Job type\r\n  enum JobType { ONEOFF, PARTTIME, FULLTIME }\r\n\r\n  /**\r\n    @dev Camp all kinds of fees applicable.\r\n      o PROBATION: By jobbers on sign up.\r\n      o APPROVED: By jobbers while upgrading.\r\n      o CANCELLATION: Paid by Hirer for cancelling jobs that are already engaged.\r\n      o PLATFORMONCANCEL: In favor of the platform, computed on gross value of CANCELLATION.\r\n      o WITHDRAWAL: BY Jobbers as % of earning.\r\n  */\r\n  enum Fees { PROBATION, APPROVED, CANCELLATION, PLATFORMONCANCEL, WITHDRAWAL}\r\n\r\n  // /**@dev Categories of jobber.  */\r\n  // enum Tier { NONE, PROBATION, APPROVED }\r\n\r\n  // struct Membership {\r\n  //   Tier status;\r\n  //   uint id;\r\n  // }\r\n\r\n  /**\r\n    @dev Post a new job. \r\n    @param jobRef - Link or any reference of type string to the job.\r\n    @param proposedEndDateInDays - Proposed/preferred assigned time to execute the job.\r\n    Note - Should be in days.\r\n  */\r\n\r\n  // struct Spot {\r\n  //   address trustee;\r\n  // }\r\n\r\n  function postJob(\r\n    uint8 jobType,\r\n    string memory title,\r\n    string[] memory tags,\r\n    string memory jobRef, \r\n    uint16 proposedEndDateInDays, \r\n    uint offerPrice, \r\n    uint curatorId\r\n  ) external payable returns(uint jobId);\r\n  function requestToWork(uint256 jobId, uint16 proposedCompletionDateInDays, uint256 myBestPrice) external returns(bool);\r\n  function approveRequests(uint jobId, uint8[] memory selectedPositions) external returns(bool);\r\n  function submitAndSignCompletion(uint jobId) external returns(bool);\r\n  function approveCompletion(uint jobId) external returns(bool);\r\n  function cancelJob(uint jobId) external returns(bool);\r\n  // function becomeAJobber() external payable returns(bool);\r\n  function getJobInfo(uint jobId) external view returns(JobMetadata memory);\r\n\r\n// export enum JobType { ONEOFF, PARTTIME, FULLTIME }\r\n// tags: string[]; // -------\r\n// type: JobType;\r\n// title: string;\r\n\r\n  //Job's subdata type\r\n  struct Metadata {\r\n    JobType jobType;\r\n    bytes title;\r\n    bytes jobRef;\r\n    uint8 signature;\r\n    uint64 datePosted;\r\n    uint64 proposeEnd;\r\n    uint256 offerPrice;\r\n    address hirer;\r\n    JobStatus jStatus;\r\n  \r\n  }\r\n\r\n  //Job data type\r\n  struct JobMetadata {\r\n    Metadata job;\r\n    Jobber[] requests;\r\n    bytes[] tags;\r\n    address curator;\r\n  }\r\n\r\n  //Jobber's data type\r\n  struct Jobber {\r\n    uint64 proposedJobEnd;\r\n    uint256 myBestPrice;\r\n    address identifier;\r\n    bool signed;\r\n    bool acceptance;\r\n  }\r\n\r\n  // // membership\r\n  // struct MembershipBase {\r\n  //   uint probFee;\r\n  //   // uint approFee;\r\n  //   address approver;\r\n  //   address probationer;\r\n  //   address upgrader;\r\n  // }\r\n\r\n}\r\n"
    },
    "contracts/main/interfaces/ITrustee.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"./IJob.sol\";\r\n\r\ninterface ITrustee {\r\n  error NothingToWithdraw();\r\n\r\n  function splitPayment(\r\n    IJob.Jobber[] memory tos, \r\n    uint netPay,\r\n    uint fee,\r\n    uint refundable,\r\n    address feeTo\r\n  ) external returns(bool);\r\n\r\n  function withdraw() external payable returns(bool);\r\n}"
    },
    "contracts/main/jobbers/IJobbers.sol": {
      "content": "// SPDX-License-Identifier: MIT \r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"../interfaces/ICommon.sol\";\r\n\r\ninterface IJobbers {\r\n  event MembershipUpgraded(address indexed who);\r\n  event MembershipDowngraded(address indexed who);\r\n\r\n  function becomeAJobber(\r\n    string memory name,\r\n    string memory aka,\r\n    string memory field,\r\n    string memory profileURI,\r\n    string memory avatar\r\n  ) external payable returns(bool);\r\n  function queryStatus(address target) external view returns(uint8);\r\n  function getAvatarInfo(\r\n    address jobber\r\n  ) external view returns(uint);\r\n}"
    },
    "contracts/main/jobbers/Jobbers.sol": {
      "content": "// SPDX-License-Identifier: MIT \r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"./IJobbers.sol\";\r\nimport \"../../utils/Lib.sol\";\r\nimport \"../../../node_modules/@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../../../node_modules/@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"../../tokens/erc721/interfaces/IERC721Extended.sol\";\r\nimport \"../../../node_modules/@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"../../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract Jobbers is IJobbers, Ownable, Pausable {\r\n  using Address for address;\r\n  using Lib for *;\r\n\r\n  //Members count\r\n  uint256 public counter;\r\n\r\n  //Account to receive fee\r\n  address public feeTo;\r\n\r\n  // Fee denominated in cUSD\r\n  IERC20 public feeDenom;\r\n\r\n  ///@dev Membership controller\r\n  ICommon.MembershipBase public mShip;\r\n\r\n  ///@dev Membership zone\r\n  mapping (address => uint) public ids;\r\n\r\n  ICommon.Membership[] private jobbers;\r\n\r\n  modifier checkmate(bool condition, string memory errorMessage) {\r\n    require(condition, errorMessage);\r\n    _;\r\n  }\r\n\r\n  modifier onlyApprovedOrOwner() {\r\n    require(\r\n      mShip.upgrader != address(0) &&\r\n      (_msgSender() == mShip.upgrader ||\r\n      _msgSender() == owner()),\r\n    \"Not authorized\"\r\n   );\r\n    _;\r\n  }\r\n\r\n  /**@dev We made an initial push to the jobbers array. This is to ensure \r\n    any unregistered user have a default id of 0.\r\n   */\r\n  constructor(\r\n    address _feeTo,\r\n    // uint _probFee, \r\n    address _probationer, \r\n    address _approver,\r\n    address _upgrader,\r\n    IERC20 _feeDenom\r\n  ) { \r\n    mShip.upgrader = _upgrader; \r\n    feeTo = _feeTo;\r\n    jobbers.push();\r\n    _initialize(1e17 wei, _probationer, _approver, _upgrader, _feeDenom);\r\n  }\r\n\r\n  receive() external payable {}\r\n\r\n  function _initialize (uint _probFee, address _probationer, address _approver, address _upgrader, IERC20 _feeDenom) private {\r\n    mShip = ICommon.MembershipBase(_probFee, _approver, _probationer, _upgrader);\r\n    feeDenom = _feeDenom;\r\n  }\r\n\r\n  function _getId(address target) internal view returns(uint _return) {\r\n    _return = jobbers[ids[target]].avatarId;\r\n  }\r\n\r\n  /**@dev Internal - Returns membership status of caller\r\n    @param target - Address of caller\r\n  */\r\n  function _status(address target) internal virtual view returns(ICommon.Tier _returnMsg) {\r\n    _returnMsg = jobbers[ids[target]].status;\r\n  }\r\n\r\n  // ///@dev Forward fee 'value' to 'feeTo'\r\n  // function _forwardFee(uint value) internal virtual {\r\n  //   (bool s,) = feeTo.call{value: value}(\"\");\r\n  //   require(s, \"Jobber: Sending fee failed\");\r\n  // }\r\n\r\n\r\n  /**@dev View - Returns membership status of caller\r\n    Using an array of string literal in memory, we\r\n    return membership status.\r\n   */\r\n  function myStatus() public view returns(string memory) \r\n  {\r\n    string[3] memory str = [\"None\", \"Probation\", \"Approved\"];\r\n    uint8 idx = uint8(_status(_msgSender()));\r\n    return str[idx];\r\n  }\r\n\r\n  function queryStatus(address target) external view returns(uint8) {\r\n    return uint8(_status(target));\r\n  }\r\n\r\n  /**\r\n  @dev Signs up 'target'\r\n      @notice When jobbers sign up, Probation membership NFT is minted to the 'target' address. \r\n  */\r\n  function _signUp(\r\n    address target,\r\n    string memory name,\r\n    string memory aka,\r\n    string memory field,\r\n    string memory profileURI,\r\n    string memory avatar\r\n\r\n  ) private checkmate(_status(target) == ICommon.Tier.NONE,\"19\"){\r\n    counter ++;\r\n    uint id = counter;\r\n    IERC721Extended(mShip.probationer).mint(target, id);\r\n    ids[target] = id;\r\n    jobbers.push(\r\n      ICommon.Membership(\r\n        ICommon.Tier.PROBATION,\r\n        id,\r\n        ICommon.JobberData(\r\n          name.encode(),\r\n          aka.encode(),\r\n          field.encode(),\r\n          profileURI.encode(),\r\n          avatar.encode(),\r\n          0\r\n        ) \r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n  @dev User sign up to be probation member.\r\n    o Caller's current membership status must be null.\r\n    o Must send along with call the sufficient value for signup fee.\r\n    Note: Fee is denominated in stablecoin e.g cUSD\r\n  */\r\n  function becomeAJobber(\r\n    string memory name,\r\n    string memory aka,\r\n    string memory field,\r\n    string memory profileURI,\r\n    string memory avatar\r\n  ) external payable whenNotPaused returns(bool) {\r\n    uint probFee = mShip.probFee;\r\n    // if(msg.value < probFee) revert();\r\n    require(msg.value >= probFee, \"Jobber: Insufficient signup value\");\r\n    address caller = _msgSender();\r\n    address cUSD = address(feeDenom);\r\n    cUSD\r\n      .getAllowance(caller, address(this))\r\n        .uint256GE(probFee, 'Allowance not enough')\r\n          .spendAllowance(cUSD, caller, feeTo);\r\n\r\n    _signUp(_msgSender(), name, aka, field, profileURI, avatar);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    @dev Upgrade 'target' from probation to Approved member.\r\n      @param target - address to upgrade.\r\n      Note - 'target' must already be on probation before now.\r\n   */\r\n  function _upgrade(address target) private checkmate(_status(target) == ICommon.Tier.PROBATION,\"18\"){\r\n    uint id = _getId(target);\r\n    IERC721Extended(mShip.approver).mint(target, id);\r\n    IERC721Extended(mShip.probationer).burn(id);\r\n    jobbers[ids[target]].status = ICommon.Tier.APPROVED;\r\n  }\r\n\r\n    /**\r\n    @dev Downgrade 'target' from Approved member to probation.\r\n      @param target - address of target to downgrade.\r\n      Note - 'target' must already be an approved member before now.\r\n   */\r\n  function _downgrade(address target) private checkmate(_getId(target) > 0, \"18\"){\r\n    ICommon.Membership memory _m = jobbers[ids[target]];\r\n    uint id = _getId(target);\r\n    ICommon.Tier newStatus;\r\n    if(_m.status == ICommon.Tier.APPROVED) {\r\n      newStatus = ICommon.Tier.PROBATION;\r\n      require(\r\n        IERC721Extended(mShip.approver).burn(id) &&\r\n        IERC721Extended(mShip.probationer).mint(target, id),\r\n        \"21\"\r\n      );\r\n    }\r\n\r\n    if(_m.status == ICommon.Tier.PROBATION) {\r\n      newStatus = ICommon.Tier.NONE;\r\n      id = 0;\r\n      IERC721Extended(mShip.probationer).burn(id);\r\n    }\r\n\r\n    jobbers[id].avatarId = id;\r\n    jobbers[id].status = newStatus;\r\n\r\n  }\r\n\r\n    // Set Miscellaneous\r\n  function updateMembershipInfo(\r\n    uint _probFee,\r\n    address _approver,\r\n    address _probationer,\r\n    address _upgrader,\r\n    IERC20 _feeDenom\r\n  ) public onlyOwner {\r\n    _initialize(_probFee, _probationer, _approver, _upgrader, _feeDenom);\r\n  }\r\n\r\n  function pauseAvatarContract(uint8 selector) public onlyOwner {\r\n    address[2] memory nfts = [mShip.probationer, mShip.approver];\r\n    IERC721Extended(nfts[selector]).pause();\r\n  }\r\n\r\n  function unpauseAvatarContract(uint8 selector) public onlyOwner {\r\n    address[2] memory nfts = [mShip.probationer, mShip.approver];\r\n    IERC721Extended(nfts[selector]).unpause();\r\n  }\r\n\r\n    /**\r\n    @dev Upgrade or downgrade'target'\r\n      o 'target' must be the probation member.\r\n      o Upgrader must be approved client.\r\n   */\r\n  function upgradeOrDowngradeUser(address target, uint8 upgrade_) public whenNotPaused onlyApprovedOrOwner {\r\n    if(upgrade_ == 1) {\r\n      _upgrade(target);\r\n      emit MembershipUpgraded(target);\r\n    } else {\r\n      _downgrade(target);\r\n      emit MembershipDowngraded(target);\r\n    }\r\n  }\r\n\r\n  function withdraw(address to, address erc20, uint amount) public onlyOwner() {\r\n    if(to != address(0)) {\r\n      if(erc20 != address(0) && erc20.isContract()) {\r\n        require(IERC20(erc20).transfer(to, amount), \"ERC20 Transfer failed\");\r\n      } else {\r\n        (bool s,) = to.call{value: amount}('');\r\n        require(s, 'Value Transfer failed.');\r\n      }\r\n    }\r\n  }\r\n\r\n  function getJobbers() public view returns(ICommon.Membership[] memory _return) {\r\n    _return = jobbers;\r\n    return _return;\r\n  }\r\n\r\n  function getAvatarInfo(\r\n    address jobber\r\n  ) external view returns(uint) {\r\n    return IERC721(mShip.probationer).balanceOf(jobber); \r\n  }\r\n\r\n  function getAvatarId(address _of) public view returns(uint) {\r\n    return _getId(_of);\r\n  }\r\n\r\n}"
    },
    "contracts/main/ReadOnly.sol": {
      "content": "/** SPDX-License-Identifier: MIT*/\r\npragma solidity 0.8.19;\r\n\r\nimport \"./Storage.sol\";\r\n\r\nabstract contract ReadOnly is Storage {\r\n\r\n  /**@dev Returns list of interested participants for a job \r\n          @param jobId - {job index} */\r\n  function getRequests(uint jobId) public view isJobIdValid(jobId) returns(Jobber[] memory) \r\n  {\r\n    return _getJobRequests(jobId);\r\n  }\r\n\r\n  // /**@dev View - Returns membership status of caller\r\n  //   Using an array of string literal in memory, we\r\n  //   return membership status.\r\n  //  */\r\n  // function myStatus() public view returns(string memory) \r\n  // {\r\n  //   string[3] memory str = [\"None\", \"Probation\", \"Approved\"];\r\n  //   uint8 idx = _status(msg.sender);\r\n  //   return str[idx];\r\n  // }\r\n\r\n\r\n  /**@dev Read single job from storage.\r\n      @param jobId - Job index\r\n  */\r\n  function getJobInfo(uint jobId) external view isJobIdValid(jobId) returns(JobMetadata memory) {\r\n    return _getJobData(jobId);\r\n  }\r\n\r\n  /**@dev Read all jobs from storage.\r\n  */\r\n  function viewJobs() public view returns(JobMetadata[] memory all) {\r\n    return _getAllJobs();\r\n  }\r\n\r\n  /**\r\n    @dev See { Storage - _getPosition} \r\n      @param jobId - Job index/position.\r\n  */\r\n  function getPosition(address jobber, uint jobId) public view isJobIdValid(jobId) returns (uint8) \r\n  {\r\n    return uint8(_getPosition(jobber, jobId));\r\n  }\r\n\r\n}"
    },
    "contracts/main/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"./Trustee.sol\";\r\nimport \"../utils/Lib.sol\";\r\nimport \"./interfaces/IJob.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/interfaces/IERC721.sol\";\r\nimport \"../tokens/erc721/interfaces/IERC721Extended.sol\";\r\nimport \"./jobbers/IJobbers.sol\";\r\n\r\n/** \r\n  \r\n    ERROR CODE\r\n    ----------\r\n    \"1\" : Not a member.\r\n    \"3\" : Ownership not found.\r\n    \"5\" : Transfer failed.\r\n    \"7\" : Invalid entry.\r\n    \"10\" : Probation period is over.\r\n    \"12\" : Max of 5 collaborators for a job.\r\n    \"16\" : Job cannot be canceled at this stage.\r\n    \"18\" : Target level differs.\r\n    \"19\" : Type out of bound\r\n*/\r\n\r\nabstract contract Storage is IJob {\r\n  using Lib for *;\r\n\r\n  ///@dev Minimum threshold for all job offers.\r\n  uint256 public minimMumOffer;\r\n\r\n  // //Members count\r\n  // uint256 public counter;\r\n\r\n  address public jobberContract;\r\n\r\n  //Account to receive fee\r\n  address public feeTo;\r\n\r\n  // Stablecoin address i.e cUSD\r\n  address public paymentCurrency;\r\n\r\n  ///@dev Cancellation rate\r\n  uint8 public cancellationRate;\r\n\r\n  ///@dev Limits the offer probationary members can accept.\r\n  uint public probationOfferLimit;\r\n\r\n  // ///@dev Membership controller\r\n  // MembershipBase public mShip;\r\n\r\n  // Array of jobs\r\n  JobMetadata[] private jobs;\r\n\r\n  /**@dev Mapping of addresses in Jobs to position \r\n    i.e Jobber's position in the list of collaborators\r\n    for each posted jobs.\r\n  */ \r\n  mapping(address => mapping(uint => uint8)) private positions;\r\n\r\n  //Mapping of Jobbers to compliance\r\n  mapping(address => uint64) private compliance;\r\n\r\n  // /**\r\n  //   @dev Reward base. \r\n  //   Note - When updating, should not include decimals e.g 10, 30, 240 etc\r\n  // */\r\n  // mapping(Tier=>uint32) private rewardBase;\r\n\r\n  // ///@dev Membership zone\r\n  // mapping (address => Membership) public ids;\r\n\r\n  /**@dev Guards against error accessing non-exisitng item in the job array.\r\n            Job must be in an acceptable status.\r\n  */\r\n  modifier enforceJobStatus(uint256 jobId, JobStatus _jobStat)\r\n  {\r\n    uint8 jStatus = uint8(jobs[jobId].job.jStatus);\r\n    jStatus.uint8Eq(uint8(_jobStat), \"12\");\r\n    _;\r\n  }\r\n\r\n  modifier isJobIdValid(uint jobId) {\r\n    uint jobIndex = jobs.length;\r\n    jobId.uint256LE(jobIndex, \"7\");\r\n    _;\r\n  }\r\n\r\n  // modifier checkmate(bool condition, string memory errorMessage) {\r\n  //   require(condition, errorMessage);\r\n  //   _;\r\n  // }\r\n\r\n  constructor(address _feeTo) {\r\n    feeTo = _feeTo;\r\n  }\r\n\r\n  function _initialize (\r\n    uint8 _cancellationRate, \r\n    uint _minimMumOffer, \r\n    address _paymentCurrency,\r\n    address _jobbersContract\r\n  )\r\n    internal \r\n  {\r\n    minimMumOffer = _minimMumOffer;\r\n    cancellationRate = _cancellationRate;\r\n    paymentCurrency = _paymentCurrency;\r\n    jobberContract = _jobbersContract;\r\n  }\r\n\r\n  function _now() internal view returns(uint64 _return) {\r\n    _return = uint64(block.timestamp);\r\n  }\r\n\r\n  /**@dev Cancels job @param jobId - {job index}\r\n    Note : Hirer is at liberty to cancel job anytime if:\r\n        - Deadline has elapsed, or\r\n        - Job in states other than completed.\r\n      o Cannot cancel completed jobs.\r\n    They're surcharged if wish to cancel when it is opened or taken and interest already shown.\r\n    Cancellation fee (less platform fee) is splitted among collaborators.\r\n  \r\n   */\r\n  function _removeJob(uint jobId) internal virtual isJobIdValid(jobId) returns (uint refund, uint platformFee, uint splittable, Jobber[] memory requests) {\r\n    JobMetadata memory j = _getJobData(jobId);\r\n    requests = j.requests;\r\n    refund = j.job.offerPrice;\r\n    msg.sender.addressEq(j.job.hirer, \"3\");\r\n    require(uint8(j.job.jStatus) < uint8(JobStatus.COMPLETED), \"16\");\r\n\r\n    if(j.job.jStatus == JobStatus.TAKEN || _now() > (j.job.datePosted + 24 hours)) {\r\n      uint8 rate = _getCancellationRate();\r\n      if(rate > 0) {\r\n        uint cancellationFee = (refund * rate) / 100;\r\n        unchecked {\r\n          refund = refund - cancellationFee;\r\n          platformFee = (cancellationFee * 15) / 100;\r\n          splittable = cancellationFee - platformFee;\r\n        }\r\n      }\r\n    }\r\n    \r\n    delete jobs[jobId];\r\n  }\r\n\r\n  //Returns cancellation rate: #Gas saving\r\n  function _getCancellationRate() internal view returns (uint8 cRate) {\r\n    cRate = cancellationRate;\r\n  }\r\n\r\n  /**\r\n    @dev Returns job at jobId in storage \r\n      @param jobId - Job index/position.\r\n  */\r\n  function _getJobData(uint jobId) internal view virtual returns (JobMetadata memory _jobD ){ \r\n    _jobD = jobs[jobId]; \r\n  }\r\n\r\n  /**\r\n    @dev Populates job in job array in storage \r\n      @param jobRef - Job link or can be any string or byte;\r\n      @param proposeEnd - Expected time to complete job;\r\n      @param offerPrice - Price offer for this job;\r\n        Note - We explicitly initialize 5 empty interest slots for \r\n                each job created.\r\n    \r\n      @notice \r\n      \r\n      Noticable error:\r\n            Using the current compiler version in the truffle config file, I get \r\n              compiler error while trying to instantiate a new request, which is \r\n              more like copying from memory to the storage, and solidity seems not \r\n              support such operation at this time.\r\n\r\n              jobs.push(jobber({\r\n                jobRef: jobRef,\r\n                datePosted: uint32(block.timestamp),\r\n                proposeEnd: uint32(proposeEnd),\r\n                offerPrice: offerPrice,\r\n                hirer: msg.sender,\r\n                jStatus: JobStatus.OPEN,\r\n                requests: new jobber[](5)  <=== This part causes a panic, and the program exit, producing the following Compile error.\r\n              }))\r\n\r\n              CompileError: UnimplementedFeatureError: Copying of type struct Iprobationer.jobber memory[] memory to storage not yet supported.\r\n\r\n              This could have been the easiest way of creating an empty request array. Notwithstanding, to most problem, there is \r\n              at least a way out.\r\n  */\r\n  function _postJob( \r\n    uint8 jobType,\r\n    string memory title,\r\n    string[] memory tags,\r\n    string memory jobRef, \r\n    uint256 proposeEnd, \r\n    uint256 offerPrice,\r\n    address hirer,\r\n    address curator\r\n  ) internal virtual returns(uint jobId) {\r\n    require(jobType < 3, \"19\");\r\n    jobId = jobs.length;\r\n    jobs.push();\r\n    jobs[jobId].job = Metadata(\r\n                                JobType(jobType),\r\n                                title.encode(),\r\n                                jobRef.encode(), \r\n                                0, \r\n                                _now(), \r\n                                uint64(proposeEnd), \r\n                                offerPrice, \r\n                                hirer, \r\n                                JobStatus.OPEN\r\n                              );\r\n    jobs[jobId].curator = curator;\r\n    for(uint8 i = 0; i < tags.length; i++) {\r\n      jobs[jobId].tags.push(tags[i].encode());\r\n    }\r\n  }\r\n\r\n  /**\r\n    @dev Returns position for jobber on job at jobId in storage \r\n      @param jobber - Subject.\r\n      @param jobId - Job index/position.\r\n  */\r\n  function _getPosition(address jobber, uint jobId) internal view virtual returns (uint8) \r\n  { return positions[jobber][jobId]; }\r\n\r\n  /**\r\n     @dev Returns updates position for jobber \r\n      @param jobber - Subject.\r\n      @param jobId - Job index/position.\r\n  */\r\n  function _assignAndUpdateIndex(address jobber, uint jobId) internal virtual returns (uint8)\r\n  {\r\n    uint8 newPos = _createNewIndex(jobId);\r\n    positions[jobber][jobId] = newPos;\r\n    return newPos;\r\n  }\r\n\r\n  /**\r\n    @dev Returns interests for job at jobId in storage \r\n      @param jobId - Job index/position.\r\n  */\r\n  function _getJobRequests(uint jobId) internal virtual view returns (Jobber[] memory req) \r\n  {\r\n    req = jobs[jobId].requests;\r\n  }\r\n\r\n  /**\r\n     @dev Returns updates position for jobber \r\n      @param jobber - Subject.\r\n      @param jobId - Job index/position.\r\n      @param proposedCompletionDateInDays - Jobber's proposed completion \r\n            time (in days),\r\n      @param proposedOffer - Jobber's preferred price.\r\n  */\r\n  function _createAndUpdateNewRequest(\r\n    address jobber, \r\n    uint jobId,\r\n    uint64 proposedCompletionDateInDays,\r\n    uint proposedOffer\r\n  ) internal virtual \r\n  {\r\n    _assignAndUpdateIndex(jobber, jobId);\r\n    jobs[jobId].requests.push(\r\n      Jobber(\r\n        proposedCompletionDateInDays,\r\n        proposedOffer,\r\n        jobber,\r\n        false,\r\n        false\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n    @dev Returns all jobs in storage \r\n  */\r\n  function _getAllJobs() internal virtual view returns (JobMetadata[] memory _jobs) \r\n  {\r\n    _jobs = jobs;\r\n    return _jobs;\r\n  }\r\n  \r\n  // ///@dev Forward fee 'value' to 'feeTo'\r\n  // function _forwardFee(uint value) internal virtual {\r\n  //   (bool s,) = feeTo.call{value: value}(\"\");\r\n  //   s.boolEq(true, \"5\");\r\n  // }\r\n\r\n  /**\r\n    @dev Returns job at jobId from storage \r\n      @param jobber - Subject\r\n  */\r\n  function _getCompliance(address jobber) internal virtual view returns (uint64) \r\n  {\r\n    return compliance[jobber];\r\n  }\r\n\r\n  /**\r\n    @dev Returns job at jobId from storage \r\n      @param jobber - Subject\r\n      @param value - Value to update for subject\r\n  */\r\n  function _postComplianceFor(address jobber, uint value) internal virtual \r\n  {\r\n    compliance[jobber] = uint32(value);\r\n  }\r\n\r\n  /**@dev Generates new interest position for @param jobId - {Job index} */\r\n  function _createNewIndex(uint jobId) private view returns (uint8) \r\n  {\r\n    return uint8(jobs[jobId].requests.length);\r\n  }\r\n\r\n  function _queryJobberStatus(address target) internal virtual view returns(uint8 _return) {\r\n    _return = IJobbers(jobberContract).queryStatus(target);\r\n  }\r\n\r\n  /**@dev Enforces compliance. Jobbers with HiWork Probationary Membership\r\n        are expected to upgrade within 60 days by undergoing compentency \r\n        test to upgrade by interacting with the probationer contract. \r\n\r\n      @notice - If jobber already passed test, they're encouraged to explicitly upgrade\r\n        by calling designated function.\r\n  */\r\n  function _enforceCompliance(address caller) \r\n    internal\r\n    virtual \r\n  {\r\n    uint8 _status = _queryJobberStatus(caller);\r\n    if(_status == 1) //i.e \"Member on probation. \r\n    {\r\n      uint64 startProbation = _getCompliance(caller);\r\n      if(startProbation == 0) compliance[caller] = uint64(block.timestamp);\r\n      else require(block.timestamp < startProbation + (60 * 1 days), \"10\");\r\n    }\r\n\r\n    if(_status == 0) revert (\"1\");\r\n  }\r\n\r\n  /**@dev Internal: Updates Job completion status. */\r\n  function _setStatus(uint jobId, JobStatus status) internal virtual returns (bool) \r\n  {\r\n    jobs[jobId].job.jStatus = status;\r\n    return true;\r\n  }\r\n\r\n  /**@dev Updates signature for job \r\n        @param jobId {Job index} with \r\n        @param value - {New signature}\r\n  */\r\n  function _updateSignature(uint jobId, uint8 value) internal virtual \r\n  {\r\n    jobs[jobId].job.signature = value;\r\n  }\r\n\r\n  /**@dev Updates signature for specific job \r\n        @param jobId {Job index} with \r\n        @param pos - Jobber's position\r\n  */\r\n  function _updateSignedFlag(uint jobId, uint8 pos) internal virtual \r\n  {\r\n    jobs[jobId].requests[pos].signed = true;\r\n  }\r\n\r\n  /**@dev Updates request for Jobber at pos \r\n      @param jobId - job Index\r\n      @param pos - Position of jobber for whom to update request\r\n  */\r\n  function _updateRequest(uint jobId, uint8 pos) internal virtual \r\n  {\r\n    jobs[jobId].requests[pos].acceptance = true;\r\n  }\r\n\r\n  // /**@dev Internal - Returns membership status of caller\r\n  //       @param target - Address of caller\r\n\r\n  // */\r\n  // function _status(address target) internal virtual view returns(uint8 _returnMsg) \r\n  // {\r\n  //   _returnMsg = uint8(ids[target].status);\r\n  // }\r\n\r\n  ///@dev Sets cancellatioon rate\r\n  function _setCancellationRate(uint8 newFeeRate) internal virtual \r\n  {\r\n    _beforeInvocation();\r\n    cancellationRate = newFeeRate;\r\n  }\r\n\r\n  // /**\r\n  //   @dev Signs up 'target'\r\n  //       @notice When jobbers sign up, Probation membership NFT is minted to the 'target' address. \r\n  //  */\r\n  // function _signUp(address target) internal checkmate(ids[target].status == Tier.NONE,\"19\"){\r\n  //   counter ++;\r\n  //   uint id = counter;\r\n  //   IERC721Extended(mShip.probationer).mint(target, id);\r\n  //   ids[target] = Membership(Tier.PROBATION, id);\r\n  // }\r\n\r\n\r\n  // /**\r\n  //   @dev Upgrade 'target' from probation to Approved member.\r\n  //     @param target - address to upgrade.\r\n  //     Note - 'target' must already be on probation before now.\r\n  //  */\r\n  // function _upgrade(address target) internal checkmate(ids[target].status == Tier.PROBATION,\"18\"){\r\n  //   uint id = ids[target].id;\r\n  //   IERC721Extended(mShip.approver).mint(target, id);\r\n  //   IERC721Extended(mShip.probationer).burn(id);\r\n  //   ids[target].status = Tier.APPROVED;\r\n  // }\r\n\r\n  // /**\r\n  //   @dev Downgrade 'target' from Approved member to probation.\r\n  //     @param target - address of target to downgrade.\r\n  //     Note - 'target' must already be an approved member before now.\r\n  //  */\r\n  // function _downgrade(address target) internal virtual checkmate(ids[target].id > 0, \"18\"){\r\n  //   _beforeInvocation();\r\n  //   Membership memory _m = ids[target];\r\n  //   uint id = ids[target].id;\r\n  //   Tier newStatus;\r\n  //   if(_m.status == Tier.APPROVED) {\r\n  //     newStatus = Tier.PROBATION;\r\n  //     require(\r\n  //       IERC721Extended(mShip.approver).burn(id) &&\r\n  //       IERC721Extended(mShip.probationer).mint(target, id),\r\n  //       \"21\"\r\n  //     );\r\n  //   }\r\n\r\n  //   if(_m.status == Tier.PROBATION) {\r\n  //     newStatus = Tier.NONE;\r\n  //     id = 0;\r\n  //     IERC721Extended(mShip.probationer).burn(id);\r\n  //   }\r\n\r\n  //   ids[target] = Membership(newStatus, id);\r\n\r\n  // }\r\n\r\n  function _updateProposeEndDate(uint jobId, uint64 newDate) internal {\r\n    jobs[jobId].job.proposeEnd = newDate; \r\n  }\r\n\r\n  // ///@dev Returns reward base\r\n  // function _getRewardBase(uint8 cmd) internal view virtual returns(uint32 _return) {\r\n  //   _return = rewardBase[Tier(cmd)];\r\n  // }\r\n\r\n  // // Set Miscellaneous\r\n  // function _setMembershipVars(\r\n  //   uint probFee,\r\n  //   // uint approFee,\r\n  //   address approver,\r\n  //   address probationer,\r\n  //   address upgrader\r\n  // ) public virtual {\r\n  //   _beforeInvocation();\r\n  //   mShip = MembershipBase(\r\n  //     probFee,\r\n  //     // approFee,\r\n  //     approver,\r\n  //     probationer,\r\n  //     upgrader\r\n  //   );\r\n  // }\r\n\r\n  function setOfferLimit(uint _newLimit) public {\r\n    _beforeInvocation();\r\n    minimMumOffer = _newLimit;\r\n  }\r\n\r\n  function setProbationOfferLimit(uint _newLimit) public {\r\n    _beforeInvocation();\r\n    probationOfferLimit = _newLimit;\r\n  }\r\n  \r\n  function _beforeInvocation() internal virtual {}\r\n  function getLastJobId() public view returns(uint) {\r\n    return jobs.length;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n  // struct Metadata {\r\n  //   bytes jobType;\r\n  //   bytes title;\r\n  //   bytes jobRef;\r\n  //   uint8 signature;\r\n  //   uint64 datePosted;\r\n  //   uint64 proposeEnd;\r\n  //   uint256 offerPrice;\r\n  //   address hirer;\r\n  //   JobStatus jStatus;\r\n  \r\n  // }\r\n\r\n  // //Job data type\r\n  // struct JobMetadata {\r\n  //   Metadata job;\r\n  //   Jobber[] requests;\r\n  //   bytes[] tags;\r\n  //   address curator;\r\n  // }"
    },
    "contracts/main/Trustee.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"./interfaces/ITrustee.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/**\r\n  @title Trustee: Manages payment for parties to job i.e hirer and jobber.\r\n  @author Bobeu : https://github.com/bobeu \r\n\r\n  ERROR CODE\r\n  ----------\r\n  \"18\" : Withdrawal failed\r\n  \"19\" : Bal < netPay\r\n  \"20\" : NothingToWithdraw\r\n */\r\ncontract Trustee is ITrustee, Ownable, ReentrancyGuard {\r\n  // Amount withdrawable by hirer from this contract at any time.\r\n  uint256 public withdrawable;\r\n\r\n  // Amount engaged at any time\r\n  uint256 public engaged;\r\n\r\n  //Job owner\r\n  address public hirer;\r\n\r\n  // cUSD address\r\n  address public cUSD;\r\n\r\n  //Payment ledger\r\n  mapping(address => uint256) public payment;\r\n\r\n  constructor (address hirer_, address _cUSD) {\r\n    hirer = hirer_;\r\n    cUSD = _cUSD;\r\n  }\r\n\r\n  receive() external payable {}\r\n\r\n  /**\r\n    @dev Splits payment for jobbers on this hirer's request.\r\n    Note hirer is able to withdraw available balances in this contract, but \r\n        we ensure withdrawables does not affect the position of currently \r\n        engaged jobbers.\r\n  */\r\n  \r\n  function splitPayment(\r\n    IJob.Jobber[] memory tos, \r\n    uint netPay,\r\n    uint fee,\r\n    uint refundable,\r\n    address feeTo\r\n  ) external onlyOwner returns(bool) {\r\n    // require(feeTo != address(0), \"W\");\r\n    uint _balances = _getBalances();\r\n    uint size = tos.length;\r\n    uint eachPay = netPay / size;\r\n\r\n    if(_balances < (netPay + fee)) revert('19');\r\n    if(fee > 0) { _withdraw(feeTo, fee); }\r\n    if(netPay > 0) {\r\n      for(uint i = 0; i < size; i++ ){\r\n        address to = tos[i].identifier;\r\n        payment[to] += eachPay;\r\n      }\r\n    }\r\n    if(refundable > 0) {\r\n      payment[_hirer()] += refundable;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  \r\n  function _getCUSDAddr() private view returns(address _token) {\r\n    _token = cUSD;\r\n  }\r\n\r\n  /**\r\n    @dev Withdraw payment.\r\n        Only preselected address are allowed.\r\n   */\r\n  function withdraw() external payable nonReentrant returns(bool) { \r\n    address to = _msgSender();\r\n    uint pay = payment[to];\r\n    require(pay > 0, \"20\");\r\n    payment[to] = 0;\r\n    _withdraw(to, pay); \r\n    return true; \r\n  }\r\n\r\n  function _withdraw(address to, uint amount) private {\r\n    require(IERC20(_getCUSDAddr()).transfer(to, amount), '18');\r\n  \r\n  }\r\n\r\n  function _getBalances() internal view returns(uint _balances) {\r\n    address token = _getCUSDAddr();\r\n    _balances = IERC20(token).balanceOf(address(this));\r\n  } \r\n\r\n  function _hirer() internal view returns(address) { return hirer ; }\r\n}"
    },
    "contracts/tokens/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Imported from: OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"../../../node_modules/@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\r\nimport \"../../../node_modules/@openzeppelin/contracts/utils/Context.sol\";\r\n\r\n/**https://hardhat.org/migrate-from-waffle\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\nabstract contract ERC20 is Context, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    address public _factory;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_, address factory) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _factory = factory;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool _return) {\r\n        address spender = _msgSender();\r\n        if(from != _factory) {\r\n            _spendAllowance(from, spender, amount);\r\n            _transfer(from, to, amount);\r\n            _return = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimReward() public virtual returns(bool) {\r\n        address to = _msgSender();\r\n        uint amount = _allowances[_factory][to];\r\n        _spendAllowance(_factory, _msgSender(), amount);\r\n        _transfer(_factory, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _resetFactory(address newFactory) internal {\r\n        _factory = newFactory;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "contracts/tokens/erc20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Imported from: OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"./ERC20.sol\";\r\nimport \"./interfaces/IERC20Extended.sol\";\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is ERC20, IERC20Extended {\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _spendAllowance(account, _msgSender(), amount);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/erc20/interfaces/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20Extended {\r\n\r\n    /**\r\n     * @dev Mints `amount` tokens from `from` to `to` \r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Mint} event.\r\n     */\r\n    function mint(\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
    },
    "contracts/tokens/erc20/WorkToken.sol": {
      "content": "/** SPDX-License-Identifier: Unlicense\r\n Compiled using solc: 0.8.15+commit.e14f2714.Emscripten.clang \r\n*/\r\npragma solidity 0.8.19;\r\n\r\nimport \"./ERC20Burnable.sol\";\r\nimport \"../../utils/Lib.sol\";\r\nimport \"../../../node_modules/@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../../../node_modules/@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\ncontract WorkToken is Ownable, ERC20Burnable, Pausable {\r\n  using Lib for *;\r\n\r\n  //Maximum supply\r\n  uint256 public maxSupply;\r\n\r\n  constructor(address factory) ERC20(\"HiWork Token\", \"WORK\", factory) {\r\n    require(factory != address(0), \"Req. factory\");\r\n    uint mantissa = 10 ** decimals();\r\n    maxSupply = 100_000_000 * mantissa;\r\n    super._mint(_msgSender(), 50_000_000 * mantissa);\r\n    super._mint(factory, 10_000_000 * mantissa);\r\n  }\r\n\r\n  /**@dev mints WORk Token of an 'amount' to 'account' \r\n   * o Can only mint if totalSupply plus the amount to mint is less than maxSupply\r\n   *    - If caller is not expected owner, then it must be the factory account calling.\r\n   *    - If caller is the owner account, then we allow to mint.\r\n   *    - We check if the contract is not paused to execute the 'mint' instruction.\r\n  */\r\n  function mint(address account, uint256 amount) external returns(bool _ret) {\r\n    if(totalSupply() + amount <= maxSupply) {\r\n      uint actual = 0;\r\n      if(_msgSender() != owner()) {\r\n        require(_msgSender() == _factory, \"WORK: Not allowed\");\r\n        actual = amount;\r\n      }\r\n      if(_msgSender() == owner()) actual = amount;\r\n      if(!paused()){\r\n        super._mint(account, actual);\r\n        _ret = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  ///@dev Reset factory contract\r\n  function updateFactory(address newFactory) public onlyOwner {\r\n    _resetFactory(newFactory);\r\n  }\r\n\r\n}"
    },
    "contracts/tokens/erc721/interfaces/IERC721Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity  0.8.19;\r\n\r\nimport \"../../../../node_modules/@openzeppelin/contracts/interfaces/IERC721.sol\";\r\nimport \"../../../../node_modules/@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\r\nimport \"../../../../node_modules/@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\r\n\r\ninterface IERC721Extended is IERC721, IERC721Receiver, IERC721Metadata {\r\n  function pause() external;\r\n  function unpause() external;\r\n  function burn(uint256 tokenId) external returns(bool);\r\n  function mint(address to, uint256 tokenId) external returns(bool);\r\n}"
    },
    "contracts/utils/Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"../main/interfaces/ITrustee.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/interfaces/IERC20.sol\";\r\n\r\nlibrary Lib {\r\n  /**@dev Performs a double check with returned error messsage */\r\n  // function nestedCheck(\r\n  //   address actual, \r\n  //   address expected, \r\n  //   uint256 actual_1, \r\n  //   uint256 expected_1, \r\n  //   string memory errorMessage) \r\n  //     internal pure \r\n  // {\r\n  //   _compare(actual == expected, errorMessage);\r\n  //   _compare(actual_1 >= expected_1, errorMessage);\r\n  // }\r\n\r\n  /**@dev PPerform boolean equality operation */\r\n  function boolEq(bool actual, bool expected, string memory errorMessage) internal pure \r\n  {\r\n    _compare(actual == expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Perform equality operation on uint256 typed data*/\r\n  function uint8Eq(uint8 actual, uint8 expected, string memory errorMessage) internal pure\r\n  {\r\n    _compare(actual == expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Perform greater than or equals-to operation on uint8 typed data*/\r\n  function uint8Ge(uint8 actual, uint8 expected, string memory errorMessage) internal pure\r\n  {\r\n    _compare(actual >= expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Perform greater-than operation on uint8 typed data*/\r\n  // function uint8G(uint8 actual, uint8 expected, string memory errorMessage) internal pure\r\n  // {\r\n  //   _compare(actual > expected, errorMessage);\r\n  // }\r\n\r\n  /**@dev Perform less-than operation on uint8 typed data*/\r\n  function uint8L(uint8 actual, uint8 expected, string memory errorMessage) internal pure \r\n  {\r\n    _compare(actual < expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Perform equality operation on address typed data*/\r\n  function addressEq(address actual, address expected, string memory errorMessage) internal pure \r\n  {\r\n    _compare(actual == expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Perform not-equals-to operation on address typed data*/\r\n  function addressNE(address actual, address expected, string memory errorMessage) internal pure \r\n  {\r\n    _compare(actual != expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Perform equality operation on uint256 typed data*/\r\n  function uint256Eq(uint256 actual, uint256 expected, string memory errorMessage) internal pure \r\n  {\r\n    _compare(actual == expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Perform greater than or equals-to operation on uint256 typed data*/\r\n  function uint256GE(uint256 actual, uint256 expected, string memory errorMessage) internal pure returns(uint256 _return)\r\n  {\r\n    _compare(actual >= expected, errorMessage);\r\n    _return = actual;\r\n  }\r\n\r\n  /**@dev Perform greater than operation on uint256 typed data*/\r\n  function uint256G(uint256 actual, uint256 expected, string memory errorMessage) internal pure returns(uint256 _return) {\r\n    _compare(actual > expected, errorMessage);\r\n    _return = actual;\r\n  }\r\n\r\n  /**@dev Performs a single check with returned error messsage*/\r\n  function uint256L(uint256 actual, uint256 expected, string memory errorMessage) internal pure \r\n  {\r\n    _compare(actual < expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Perform less than or equals-to operation on uint256 typed data*/\r\n  function uint256LE(uint256 actual, uint256 expected, string memory errorMessage) internal pure \r\n  {\r\n    _compare(actual <= expected, errorMessage);\r\n  }\r\n\r\n  /**@dev Performs a single check with returned error messsage*/\r\n  function _compare(bool value, string memory errorMessage) internal pure \r\n  {\r\n    require(value, errorMessage);\r\n  }\r\n\r\n  /**@dev Performs a single check with returned error messsage*/\r\n  function getNetPay(uint256 grossPay) internal pure returns(uint256 _netPay, uint256 fee) {\r\n    require(grossPay >= 1 ether, \"Invalid gross amount\" );\r\n    fee = (grossPay * 5) / 100;\r\n    _netPay = grossPay - fee;\r\n  }\r\n\r\n  function getAllowance(address token, address owner, address beneficiary) internal view returns(uint allowance) {\r\n    allowance = IERC20(token).allowance(owner, beneficiary);\r\n  }\r\n\r\n  function spendAllowance(uint allowance, address token, address owner, address receiver) internal returns(uint _return) {\r\n    require(IERC20(token).transferFrom(owner, receiver, allowance));\r\n    _return = allowance;\r\n  }\r\n\r\n  function encode(string memory arg) internal pure returns(bytes memory _return) {\r\n    _return = abi.encode(arg);\r\n  }\r\n\r\n}"
    },
    "contracts/utils/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"../main/interfaces/IJob.sol\";\r\nimport \"../main/interfaces/ITrustee.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"../tokens/erc20/interfaces/IERC20Extended.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"../../node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\r\n\r\n/**\r\n * @title SafeCall\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeCall for IERC20 or ITrustee;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeCall {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeSplit(\r\n        ITrustee trustee,\r\n        IJob.Jobber[] memory tos, \r\n        uint netPay,\r\n        uint fee,\r\n        uint refund,\r\n        address feeTo\r\n    ) internal {\r\n        _callTrusteeOptionalReturn(\r\n            trustee, \r\n            abi.encodeWithSelector(\r\n                    trustee.splitPayment.selector, \r\n                    tos,\r\n                    netPay,\r\n                    fee,\r\n                    refund,\r\n                    feeTo\r\n                )\r\n            );\r\n    }\r\n\r\n    function safeMint(\r\n        IERC20Extended token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturnExt(token, abi.encodeWithSelector(token.mint.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeCall: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeCall: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeCall: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeCall: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeCall: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturnExt(IERC20Extended token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeCall: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeCall: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param trustee The trustee targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callTrusteeOptionalReturn(ITrustee trustee, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(trustee).functionCall(data, \"SafeCall: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeCall: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}